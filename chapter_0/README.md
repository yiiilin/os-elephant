# 第零章

[toc]

## 软件如何访问硬件

硬件适配设备即为IO接口，接口是一种标准，硬件按照该标准工作便实现了通用

硬件输入输出分为串行与并行，对应的接口也分串行和并行，串行硬件通过串行接口与CPU通信，反之亦然

访问外部硬件有两种方式：

1. 将外设的内存映射到某个地址范围，CPU访问该地址即为访问外设内存，如：显卡，显卡的显存被映射到主机屋里内存的低端1MB的0xB8000_0xBFFFF
2. 通过IO接口与CPU通信，即访问IO接口的寄存器

## 应用程序是什么

编译器将代码翻译为机器指令，编译器提供了库函数，库函数中有系统调用封装，这样的库也被称为运行库，机器指令会调用硬件资源完成任务

用户态与内核态是相对于CPU的概念，CPU运行在用户态（特权3级）还是内核态（特权0级）

用户进程陷入内核是指：内外部终端发生时，当前进程被终止执行，上下文被内核中断程序保存（保存至特权0级的栈中），并开始执行内核的代码

## 内存访问为什么要分段

段基址寄存器：

* cs （code segment register 代码段）
* ds （data segment register 数据段）
* es （extra segment register 附加段，可以额外做他用）
* fs （extra segment register 附加段，可以额外做他用）
* gs （extra segment register 附加段，可以额外做他用）
* ss （stack segment register 堆栈段）

16位寄存器(2^16=65536=64KB)如何访问1MB的内存（每个地址都能读入8位，即一个字节）

采用“段基址+段内偏移地址”访问，CPU自动将段基址左移4位，即乘以2^4，地址便为20位

## 代码段、数据段？程序如何执行的？

下一条命令的地址是上一条命令的地址加上上一条命令的尺寸得来的，程序计数器cs: eip，当前eip的地址加上当前指令机器码的大小就是下条指令的地址

数据段存在对齐，对齐的空隙会塞0

哪怕代码段中间夹杂了数据，依然可以通过jmp指令跳至下一个代码段

编译器将代码编译后放入连续的区域，即代码段，已经初始化的数据也放入连续的区域，即数据段，即编译器会将代码归类

CPU再保护模式下，提供了全局描述符表：GDT，每一项称为段描述符，段描述符有段的属性位（S字段，占1bit；TYPE字段，占4bit），**该表由操作系统填写**

1. 编译器负责挑选数据具备的类型，对代码进行归类
2. 操作系统通过设置GDT构建段描述符，给段设置属性
3. CPU的段寄存器被操作系统赋予选择子，确定了指向的段，执行命令时，会根据段的属性判断指令行为，若有返回则发出异常（？）

程序分段由编译器处理

readelf -e /bin/ls 可以查看ls段内容

内存分段是处理器为访问内存而采用的机制

## 不同地址的区别

## 平坦模式

实模式下，访问超过64KB的内存需要指定不同的段基址，保护模式下能直接访问4GB内存

寻址范围不像多段模型为了访问1MB的空间需要打开A20地址线

## 寄存器位宽

寄存器都是16位宽

## 大小端字节序

1. 小端是数值的低字节放在内存的低地址处，高字节放在内存的高地址处
2. 大端是数值的低字节放在内存的高地址处，高字节放在内存的低地址处

如0x12345678

从低地址到高地址

小端：0x78 0x56 0x34 0x12
大端：0x12 0x34 0x56 0x78

比较：

| 类型 | 优势 |
|---|---|
|小端|低位在低地址，强制转换数据型可以不再调整字节|
|大端|最高位符号位在第一字节，符号位可以直接取出来，容易判断正负|

## BIOS、DOS、Linux的中断区别

BIOS、DOS都运行于实模式，都通过软中断int调用，中断调用都建立在中断向量表（IVT）中

**每个中断向量4字节**（4个字节描述了中断程序的段基址和段内偏移量），**中断向量表长度为1024字节**，**可容纳256个中断向量**

中断向量的程序**由BIOS建立**，BIOS**从物理内存地址0x0000处初始化**并**在中断向量表中添加各种中断处理程序**

BIOS中断提供了硬件访问的方法，简化硬件操作

BIOS放在主板的内存（只读ROM）中，硬件的功能调用程序和初始化代码就放在此处

规范中：

1. 第一个字节是0x55
2. 第二个字节是0xAA
3. 第三个存储单位是ROM中以512字节为单位的代码长度
4. 第四个存储单元存储的是实际代码，长度为第三个存储单元表示的长度

内存的物理地址0xA0000到0xFFFFF，专门用来做映射，硬件的ROM会被映射到这片内存的某处

BIOS会扫描0xC0000到0xE0000的内存，寻找0x55和0xAA开头的内存，意味着ROM的存在

DOS 通过 0x21 指令进入中断程序后，根据ah寄存器的值调用子功能函数

Linux内核在进入保护模式后建立终端程序，使用的是中断描述符表（IDT）

linux 通过 0x80 指令进入中断程序后，根据eax寄存器的值调用子功能函数

实模式执行int指令会自动调用中断向量表，保护模式执行int指令会自动调用中断描述符表

## Section和Segment区别

section修饰的区域称为节，节具有段描述符属性，相同属性的大section集合称为segment（段），segment由链接器整理

## MBR、EBR、DBR、OBR

### MBR

MBR，Main Boot Record，主引导记录：位于硬盘0盘0道1扇区，CHS方式表示

一般扇区大小为512字节，MBR内容为：

1. 446字节引导程序及参数
2. 64字节分区表，一共四个分区，每个分区16字节，每个分区也称为次引导程序
如果分区开头1个字节为0x80，则该分区为活动分区，如果为活动分区，MBR将执行该引导程序
3. 2字节结束标记0x55和0xaa

MBR用于从BIOS手中接过系统的控制权，BIOS知道MBR在0盘0道1扇区，MBR会被BIOS加载至0x7c00，并跳过去执行

### OBR

OBR，OS Boot Record，操作系统引导记录

为了方便MBR找到活动分区的内核加载器，内核加载器的入口地址为每个分区最开始的扇区

即，各分区起始的扇区中存放的事操作系统引导程序，即内核加载器，因此扇区去也称为操作系统引导扇区

### DBR

DBR，DOS Boot Record，DOS操作系统引导记录

### EBR

EBR，Expand Boot Record，扩展分区存储分区表
